package render_test

import (
	"bytes"
	"io"
	"testing"

	"github.com/eh-am/i3-tree/pkg/render"
	"github.com/stretchr/testify/assert"
	"go.i3wm.org/i3/v4"
)

// Generates a fake tree used for testing
func fakeTree() i3.Tree {
	// Horizontal Split
	ws1 := &i3.Node{
		Name:   "1",
		Type:   i3.NodeType(i3.WorkspaceNode),
		Layout: i3.Layout(i3.SplitH),
		Nodes: []*i3.Node{
			{
				Name: "Mozilla Firefox",
				Type: i3.NodeType(i3.Con),
			},
		},
	}

	// Stacked
	ws2 := &i3.Node{
		Name:   "2",
		Type:   i3.NodeType(i3.WorkspaceNode),
		Layout: i3.Layout(i3.Stacked),
		Nodes: []*i3.Node{
			{
				Name: "Mozilla Firefox",
				Type: i3.NodeType(i3.Con),
			},
			{
				Name: "Google Chrome",
				Type: i3.NodeType(i3.Con),
			},
			{
				Name: "Chromium",
				Type: i3.NodeType(i3.Con),
			},
		},
	}

	// Vertical Split
	ws3 := &i3.Node{
		Name:   "3",
		Type:   i3.NodeType(i3.WorkspaceNode),
		Layout: i3.Layout(i3.SplitV),
		Nodes: []*i3.Node{
			{
				Name: "Mozilla Firefox",
				Type: i3.NodeType(i3.Con),
			},
			{
				Name: "VLC media player",
				Type: i3.NodeType(i3.Con),
			},
		},
	}

	// Tabbed
	ws4 := &i3.Node{
		Name:   "4",
		Type:   i3.NodeType(i3.WorkspaceNode),
		Layout: i3.Layout(i3.Tabbed),
		Nodes: []*i3.Node{
			{
				Name: "Mozilla Firefox",
				Type: i3.NodeType(i3.Con),
			},
			{
				Name: "VLC media player",
				Type: i3.NodeType(i3.Con),
			},
			{
				Name: "Slack",
				Type: i3.NodeType(i3.Con),
			},
		},
	}

	// Slightly more complex with nested panes
	ws5 := &i3.Node{
		Name:   "5",
		Type:   i3.NodeType(i3.WorkspaceNode),
		Layout: i3.Layout(i3.SplitH),
		Nodes: []*i3.Node{
			{
				Type:   i3.NodeType(i3.Con),
				Layout: i3.Layout(i3.SplitV),
				Nodes: []*i3.Node{
					{
						Name: "/bin/bash",
						Type: i3.NodeType(i3.Con),
					},
					{
						Name: "/bin/bash",
						Type: i3.NodeType(i3.Con),
					},
				},
			},
			{
				Type:   i3.NodeType(i3.Con),
				Layout: i3.Layout(i3.SplitV),
				Nodes: []*i3.Node{
					{
						Name: "/bin/bash",
						Type: i3.NodeType(i3.Con),
					},
					{
						Name: "/bin/bash",
						Type: i3.NodeType(i3.Con),
					},
				},
			},
		},
	}

	node := i3.Node{
		Name: "root",
		Type: i3.NodeType(i3.Root),

		Nodes: []*i3.Node{
			{
				Name:   "HDMI-0",
				Type:   i3.NodeType(i3.OutputNode),
				Layout: i3.Layout(i3.OutputLayout),
				Nodes: []*i3.Node{
					ws1,
					ws2,
					ws3,
					ws4,
					ws5,
				},
			},
		},
	}

	return i3.Tree{
		Root: &node,
	}
}

func TestConRendererNoColor(t *testing.T) {
	want := `[root] root
â””â”€â”€[output][output] HDMI-0
   â”œâ”€â”€[workspace][splith] 1
   â”‚  â””â”€â”€[con] Mozilla Firefox
   â”œâ”€â”€[workspace][stacked] 2
   â”‚  â”œâ”€â”€[con] Mozilla Firefox
   â”‚  â”œâ”€â”€[con] Google Chrome
   â”‚  â””â”€â”€[con] Chromium
   â”œâ”€â”€[workspace][splitv] 3
   â”‚  â”œâ”€â”€[con] Mozilla Firefox
   â”‚  â””â”€â”€[con] VLC media player
   â”œâ”€â”€[workspace][tabbed] 4
   â”‚  â”œâ”€â”€[con] Mozilla Firefox
   â”‚  â”œâ”€â”€[con] VLC media player
   â”‚  â””â”€â”€[con] Slack
   â””â”€â”€[workspace][splith] 5
      â”œâ”€â”€[con][splitv] 
      â”‚  â”œâ”€â”€[con] /bin/bash
      â”‚  â””â”€â”€[con] /bin/bash
      â””â”€â”€[con][splitv] 
         â”œâ”€â”€[con] /bin/bash
         â””â”€â”€[con] /bin/bash
`

	tree := fakeTree()

	var writer bytes.Buffer
	r := render.NewMonochromaticConsole(io.Writer(&writer))
	r.Render(&tree)

	got := writer.String()
	assert.Equal(t, want, got)
}

func TestConRendererWithColor(t *testing.T) {
	// Hacky but works for now
	// This blob was generated by piping the test result to a file
	want := `[root] root
â””â”€â”€[[35moutput[0m][output] HDMI-0
   â”œâ”€â”€[[36mworkspace[0m][[93msplith[0m] 1
   â”‚  â””â”€â”€[[34mcon[0m] Mozilla Firefox
   â”œâ”€â”€[[36mworkspace[0m][[92mstacked[0m] 2
   â”‚  â”œâ”€â”€[[34mcon[0m] Mozilla Firefox
   â”‚  â”œâ”€â”€[[34mcon[0m] Google Chrome
   â”‚  â””â”€â”€[[34mcon[0m] Chromium
   â”œâ”€â”€[[36mworkspace[0m][[33msplitv[0m] 3
   â”‚  â”œâ”€â”€[[34mcon[0m] Mozilla Firefox
   â”‚  â””â”€â”€[[34mcon[0m] VLC media player
   â”œâ”€â”€[[36mworkspace[0m][[32mtabbed[0m] 4
   â”‚  â”œâ”€â”€[[34mcon[0m] Mozilla Firefox
   â”‚  â”œâ”€â”€[[34mcon[0m] VLC media player
   â”‚  â””â”€â”€[[34mcon[0m] Slack
   â””â”€â”€[[36mworkspace[0m][[93msplith[0m] 5
      â”œâ”€â”€[[34mcon[0m][[33msplitv[0m] 
      â”‚  â”œâ”€â”€[[34mcon[0m] /bin/bash
      â”‚  â””â”€â”€[[34mcon[0m] /bin/bash
      â””â”€â”€[[34mcon[0m][[33msplitv[0m] 
         â”œâ”€â”€[[34mcon[0m] /bin/bash
         â””â”€â”€[[34mcon[0m] /bin/bash
`

	tree := fakeTree()

	var writer bytes.Buffer
	r := render.NewColoredConsole(io.Writer(&writer))
	r.Render(&tree)

	got := writer.String()
	assert.Equal(t, want, (got))
}

func TestConRendererWithFocusedBranch(t *testing.T) {
	// Create a tree with a focused node
	focusedNode := &i3.Node{
		ID:      3,
		Name:    "Focused Window",
		Type:    i3.NodeType(i3.Con),
		Focused: true,
	}

	ws1 := &i3.Node{
		ID:     2,
		Name:   "1",
		Type:   i3.NodeType(i3.WorkspaceNode),
		Layout: i3.Layout(i3.SplitH),
		Nodes: []*i3.Node{
			focusedNode,
		},
	}

	output := &i3.Node{
		ID:     1,
		Name:   "HDMI-0",
		Type:   i3.NodeType(i3.OutputNode),
		Layout: i3.Layout(i3.OutputLayout),
		Nodes: []*i3.Node{
			ws1,
		},
	}

	root := &i3.Node{
		ID:   0,
		Name: "root",
		Type: i3.NodeType(i3.Root),
		Nodes: []*i3.Node{
			output,
		},
	}

	tree := i3.Tree{Root: root}

	// Expected output with bold markers (ANSI escape codes)
	// \x1b[1m is the code for bold on, \x1b[0m is the code for bold/color off
	want := "[root] root\n" +
		"\x1b[1mâ””â”€â”€\x1b[0m[\x1b[35moutput\x1b[0m][output] HDMI-0\n" +
		"   \x1b[1mâ””â”€â”€\x1b[0m[\x1b[36mworkspace\x1b[0m][\x1b[93msplith\x1b[0m] 1\n" +
		"      \x1b[1mâ””â”€â”€\x1b[0m\x1b[1m[\x1b[0m\x1b[34mcon\x1b[0m\x1b[1m]\x1b[0m Focused Window\n"

	var writer bytes.Buffer
	r := render.NewColoredConsole(io.Writer(&writer))
	r.Render(&tree)

	got := writer.String()
	assert.Equal(t, want, got)
}

func TestConRendererNoColorWithFocusedBranch(t *testing.T) {
	// Create a tree with a focused node (same as above but test no-color output)
	focusedNode := &i3.Node{
		ID:      3,
		Name:    "Focused Window",
		Type:    i3.NodeType(i3.Con),
		Focused: true,
	}

	ws1 := &i3.Node{
		ID:     2,
		Name:   "1",
		Type:   i3.NodeType(i3.WorkspaceNode),
		Layout: i3.Layout(i3.SplitH),
		Nodes: []*i3.Node{
			focusedNode,
		},
	}

	output := &i3.Node{
		ID:     1,
		Name:   "HDMI-0",
		Type:   i3.NodeType(i3.OutputNode),
		Layout: i3.Layout(i3.OutputLayout),
		Nodes: []*i3.Node{
			ws1,
		},
	}

	root := &i3.Node{
		ID:   0,
		Name: "root",
		Type: i3.NodeType(i3.Root),
		Nodes: []*i3.Node{
			output,
		},
	}

	tree := i3.Tree{Root: root}

	// With no color, there should be no bold codes, but still the same structure
	want := `[root] root
â””â”€â”€[output][output] HDMI-0
   â””â”€â”€[workspace][splith] 1
      â””â”€â”€[con] Focused Window
`

	var writer bytes.Buffer
	r := render.NewMonochromaticConsole(io.Writer(&writer))
	r.Render(&tree)

	got := writer.String()
	assert.Equal(t, want, got)
}
